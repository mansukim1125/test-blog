---
description: 컴퓨터 공학의 기초 과목인 컴퓨터구조론에서 '명령어 세트'에 대해 알아봅니다
---

명령어 세트: 어떤 **CPU를 위해 정의된 명령어의 집합**.

명령어 세트 설계에 필요한 사항:

- **연산 종류**: CPU가 수행할 **연산들의 수와 종류, 복잡도**.
- 데이터 유형: 연산이 수행될 데이터들의 유형.(데이터의 길이(비트 수)와 수의 표현 방식(정수, 부동소수점 수))등.
- **명령어 형식**: 명령어의 길이, 오퍼랜드 필드들의 개수와 길이.
- **주소지정 방식**: 오퍼랜드의 주소를 지정하는 방식.

## 연산의 종류

### 데이터 전송

레지스터 <-> 레지스터

레지스터 <-> 기억장치

기억장치 <-> 기억장치

간 데이터 이동. 이 과정에서 기억장치의 주소를 계산할 수 있다.

### 산술 / 논리 연산

~~(알지?)~~

### 입출력

CPU와 외부 장치들 간의 데이터 이동. 특수한 I/O 명령어들과 주소지정 방식 필요.

### 프로그램 제어

명령어 실행 순서를 변경하는 연산. (분기, 서브루틴 호출)

(교재 91쪽 그림 2-17)

#### 서브루틴 호출 명령어

- CALL: 현재의 PC 내용을 스택에 저장하고 서브루틴의 시작 주소로 분기하는 명령어

  - ```
    t0: MBR <- PC
    t1: MAR <- SP, PC <- X
    t2: M[MAR] <- MBR, SP <- SP - 1
    ```

    현재의 PC를 기억장치의 SP에 해당하는 위치에 저장. 서브루틴의 시작 주소를 PC에 저장. SP 1 감소.

    (주소지정 단위가 바이트이고 저장될 주소가 16비트이면 SP <- SP - 2)

- RET: CPU가 원래 실행하던 프로그램으로 복귀시키는 명령어

  - ```
    t0: SP <- SP + 1
    t1: MAR <- SP
    t2: PC <- M[MAR]
    ```

(교재 93쪽 그림 2-18)

## 명령어 형식

명령어 형식은 명령어 내 **필드들의 수와 배치 방식 및 각 필드의 비트 수**.

필드: 명령어의 각 구성 요소들에 소요되는 비트들의 그룹.

**명령어의 길이: 단어(word) 길이.**

연산 코드 + 오퍼랜드 + 다음 명령어 주소

### 연산 코드

연산 코드 필드의 길이: 연산 개수 결정.

4bit -> 16가지 연산 정의.

### 오퍼랜드

오퍼랜드 필드의 길이: 오퍼랜드의 범위 결정.

- 데이터: **표현 가능한 수의 범위** 결정.
- 기억장치 주소: CPU가 오퍼랜드 인출을 위해 **직접 주소를 지정할 수 있는 기억장치 용량** 결정.
- 레지스터 번호: 데이터 저장에 사용될 수 있는 **레지스터의 개수 결정**.

#### 1-주소 명령어

오퍼랜드 1개.

```
ADD X; AC <- AC + M[X]
```

(AC는 묵시적으로 지정됨.)

길이가 16비트인 1-주소 명령어의 예.

| 연산 코드 (5) | 기억장치 주소 (11) |
| ------------- | ------------------ |
|               |                    |

#### 2-주소 명령어

오퍼랜드 2개.

```
ADD R1, R2; R1 <- R1 + R2
MOV R1, R2; R1 <- R2
ADD R1, X; R1 <- X
```

길이가 16비트인 2-주소 명령어의 예.  연산 코드는 5비트, 레지스터의 수는 8개.

- 오퍼랜드 2개가 레지스터인 경우:

  | 연산 코드 (5) | 레지스터 1 (3) | 레지스터 2 (3) | (사용되지 않음) (5) |
  | ------------- | -------------- | -------------- | ------------------- |
  |               |                |                |                     |

- 오퍼랜드 중 1개가 레지스터인 경우:

  | 연산 코드 (5) | 레지스터 (3) | 기억장치 주소 (8) |
  | ------------- | ------------ | ----------------- |
  |               |              |                   |

#### 3-주소 명령어

오퍼랜드 3개.

```
ADD R1, R2, R3; R1 <- R2 + R3
```

길이가 16비트인 3-주소 명령어의 예.

| 연산 코드 (4) | 레지스터 1 (4) | 레지스터 2 (4) | 레지스터 3 (4) |
| ------------- | -------------- | -------------- | -------------- |
|               |                |                |                |

### 명령어 비교

|                       | 1-주소 명령어 | 2-주소 명령어 | 3-주소 명령어 |
| --------------------- | ------------- | ------------- | ------------- |
| 명령어 비트 수        | 작음          | 중간          | 큼            |
| 프로그램 길이         | 김            | 중간          | 짧음          |
| 명령어 수             | 많음          | 중간          | 적음          |
| 명령어 해독 시 복잡성 | 적음          | 중간          | 많음          |

## 주소지정 방식

명령어 실행에 필요한 오퍼랜드의 주소를 결정하는 방식.

**제한된 수의 명령어 비트를 사용해, 프로그래머가 여러 방법으로 오퍼랜드의 주소를 결정하도록 함.**

오퍼랜드 필드의 내용:

- 기억장치 주소
- 레지스터 번호
- 데이터

### 직접 주소지정 방식

EA = A (**오퍼랜드 필드의 내용이 유효 주소**)

- 장점: 데이터 인출을 위해 **한 번의 기억장치 접근** 필요.
- 단점: **오퍼랜드 필드의 비트 수에 따라 지정할 수 있는 기억장소 수가 제한**.

### 간접 주소지정 방식

EA = (A) (**오퍼랜드 필드의 내용이 가리키는 기억장소의 내용이 유효 주소**)

명령어 형식에 **간접비트**가 필요. (0이면 직접, 1이면 간접)

| 연산 코드 | 간접 비트 | 오퍼랜드 |
| --------- | --------- | -------- |
|           |           |          |

- 장점: 최대 기억장치 용량이 단어의 길이에 의해 결정. (주소지정 가능한 기억장치 용량이 직접 주소지정 방식에 비해 증가)
  - 단어 길이가 n비트이면, 최대 2^n개의 기억 장소를 지정.
- 단점: 실행 사이클 동안 **두 번의 기억장치 접근** 필요.

### 묵시적 주소지정 방식

명령어 실행에 **필요한 데이터의 위치가 묵시적으로 지정**되는 방식. (SHL: AC의 내용을 죄측으로 Shift)

- 장점: 명령어 길이 짧음
- 단점: 종류 제한

### 즉시 주소지정 방식

연산에 사용될 **데이터가 명령어에 포함**되어 있는 방식. 프로그램에서 레지스터나 변수의 초기 값을 어떤 상수값으로 세트하는 데 사용.

- 장점: 데이터를 인출하기 위해 **기억장치를 접근할 필요 없음**.
- 단점: 상수값의 크기가 **오퍼랜드 필드의 비트 수에 의해 제한**.

### 레지스터 주소지정 방식

EA = R (명령어의 오퍼랜드가 데이터가 저장된 레지스터를 가리키는 방식)

- 장점: 오퍼랜드 필드의 비트 수가 적어도 된다. (2^k, k는 오퍼랜드 필드의 비트 수)
- 데이터 인출을 위해 기억장치 접근이 필요 없다.
- 단점: 데이터가 저장될 수 있는 공간이 CPU 내부 레지스터로 제한.

### 레지스터 간접 주소지정 방식

EA = (R) (오퍼랜드 필드가 가리키는 레지스터의 내용을 유효 주소로 사용하는 방식)

- 장점: 주소지정 할 수 있는 기억장치 영역 확장
  - 레지스터 길이가 16비트이면, 주소지정 영역: 2^16 = 64KByte

### 변위 주소지정 방식

EA = A + (R) (직접 주소지정과 레지스터 간접 주소지정 방식의 조함)

사용되는 레지스터에 따라 여러 종류의 변위 주소지정 방식 가능.

- 상대 주소지정 방식 (PC 사용)
- 인덱스 주소지정 방식 (인덱스 레지스터 사용)
- 베이스-레지스터 주소지정 방식 (베이스 레지스터 사용)

#### 상대 주소지정 방식

EA = A + (PC) (PC를 레지스터로 사용해 EA 계산. A는 2의 보수), 주로 분기 명령어에서 사용.

A > 0: 앞으로 분기, A < 0: 뒤로 분기.

- 장점: 전체 기억장치 주소가 명령어에 포함되는 것이 아니므로 일반적인 분기 명령어보다 적은 수의 비트만 필요.
- 단점: 분기 범위가 오퍼랜드 필드의 길이에 의해 제한. (오퍼랜드 비트들로 표현 가능한 2의 보수 범위)

#### 인덱스 주소지정 방식

EA = (IX) + A (인덱스 레지스터의 내용과 변위 A를 더해 유효 주소 사용), 주로 배열 데이터를 접근할 때 사용.

IX: 인덱스 값을 저장하는 특수 목적 레지스터

- 자동 인덱싱: 명령어가 실행될 때마다 IX의 내용이 자동으로 증가 / 감소.

- 아래의 두 연산이 연속적으로 수행.

  - ```
    EA <- (IX) + A
    IX <- IX + 1
    ```

#### 베이스-레지스터 주소지정 방식

EA = (BR) + A (베이스 레지스터의 내용과 변위 A를 더해 유효 주소 결정.), 주로 프로그램의 위치 지정 혹은 변경에 사용.

다중프로그래밍 환경에서 프로그램 코드 및 데이터를 다른 위치로 이동시켜야 할 때, 분기 명령어나 데이터 접근 명령어의 주소 필드 내용을 바꿀 필요 없이 BR의 내용만 변경하면 된다.