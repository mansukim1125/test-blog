## 명령어 사이클

CPU가 한 개의 명령어를 실행하는 데 필요한 전체 처리 과정.

두 개의 부사이클(subcycle)들로 분리.

1. 인출 사이클: CPU가 기억장치로부터 명령어를 읽어 오는 단계
2. 실행 사이클: 명령어를 실행하는 단계

(교재 57쪽 그림 2-2)

## 명령어 실행에 필요한 CPU 내부 레지스터

### 프로그램 카운터

- 다음에 인출될 명령어의 주소를 가지고 있는 레지스터.
- 각 명령어가 인출된 후, 한 명령어 길이에 해당하는 주소 단위의 수만큼 증가.
- 분기(branch) 명령어가 실행되는 경우, 그 목적지 주소로 갱신.

### 누산기

- 데이터를 일시적으로 저장.
- 누산기의 비트 수는 CPU가 한 번에 연산 처리할 수 있는 데이터 비트의 수, 즉 단어의 길이.

### 명령어 레지스터

- 가장 최근에 인출된 명령어가 저장.

### 기억장치 주소 레지스터

- PC에 자장된 명령어 주소가 시스템 주소 버스로 출력되기 전 일시적으로 저장됨.
- MAR의 출력 선들이 주소 버스 선들과 직접 접속.

### 기억장치 버퍼 레지스터

- 기억장치에 저장될 데이터 / 읽혀진 데이터 일시 저장.
- MBR의 입출력 선들은 데이터 버스 선들과 직접 접속.

(교재 59쪽 그림 2-3)

## 인출 사이클

#### 인출 사이클의 마이크로 연산

```
t0: MAR <- PC
t1: MBR <- M[MAR], PC <- PC + 1
t2: IR <- MBR
```

마이크로 연산: CPU 클록의 각 주기 동안 수행되는 기본적인 동작.

1. 현재의 PC 내용을 CPU 내부 버스를 통해 MAR로 전송.
2. MAR이 지정하는 기억장치 위치로부터 읽혀진 명령어가 데이터 버스를 통해 MBR로 적재. PC의 내용 1 증가.
3. MBR에 있는 명령어 코드가 IR로 이동.

(교재 61쪽 그림 2-4)

## 실행 사이클

해당 사이클 동안 CPU는 명령어 코드를 해독하고 필요한 연산들을 수행한다. 실행 사이클에서 수행되는 마이크로 연산들은 명령어의 연산 코드에 따라 결정되므로 몇 가지 예를 들어 설명한다.

### CPU가 수행하는 연산

- 데이터 이동: CPU와 기억장치 간 혹은 CPU와 I/O 장치 간에 데이터를 이동한다.
- 데이터 처리: 데이터에 대해 산술 / 논리 연산 수행.
- 데이터 저장: 연산결과 데이터 / 입력장치에서 읽은 데이터를 기억장치에 저장.
- 프로그램 제어: 프로그램의 실행 순서 결정.

### LOAD addr

데이터를 CPU의 AC로 이동.

```
t0: MAR <- IR(addr)
t1: MBR <- M[MAR]
t2: AC <- MBR
```

1. IR의 명령어의 주소 부분을 MAR로 이동.
2. MAR이 지정한 기억장소에서 데이터 인출하여 MBR로 전송.
3. 그 데이터를 AC에 저장.

### STA addr

AC의 내용을 기억장치에 저장.

```
t0: MAR <- IR(addr)
t1: MBR <- AC
t2: M[MAR] <- MBR
```

1. IR의 명령어의 주소 부분을 MAR로 이동.
2. AC의 내용을 MBR로 이동.
3. MBR의 내용을 MAR에 해당하는 기억장소에 저장.

### ADD addr

기억장치에 저장된 데이터를 AC의 내용과 더하고, 그 결과를 다시 AC에 저장.

```
t0: MAR <- IR(addr)
t1: MBR <- M[MAR]
t2: AC <- AC + MBR
```

1. IR의 명령어의 주소 부분을 MAR에 저장.
2. MAR에 해당하는 기억장소의 내용을 MBR에 저장.
3. MBR의 값을 AC와 더하고 그 값을 AC에 저장.

(교재 64쪽 그림 2-5)

### JUMP addr

오퍼랜드가 가리키는 위치의 명령어로 분기.

```
t0: PC <- IR(addr)
```

1. IR의 명령어의 주소 부분을 PC에 저장.

### 어셈블리 프로그램 실행 과정의 예

(교재 66쪽 그림 2-6)

## 인터럽트 사이클

인터럽트: 프로그램 실행 중 CPU의 **현재 처리 순서를 중단**시키고 **다른 동작을 수행하도록 요구**하는 시스템 동작.

CPU는 어떤 장치가 **인터럽트를 요구했는지 확인**하고 해당 ISR호출하고, 서비스 **종료 후에는 원래 프로그램의 수행 계속**.

외부로부터 인터럽트 요구가 들어오면:

- CPU는 **원래의 프로그램 수행 중단** (**인터럽트가 가능한 상태로 세트되어 있는지 확인한 후**).
- 요구된 인터럽트 처리를 위한 프로그램(**인터럽트 서비스 루틴**: 인터럽트를 처리하기 위해 수행되는 프로그램 루틴)을 **먼저 수행**.

(교재 68쪽 그림 2-7)

세부 동작은 아래와 같다.

1. **현재의 PC내용을 스택에 저장**. (인터럽트 처리 완료 후 복귀할 주소를 저장.)
2. **ISR의 시작 주소를 PC에 적재**. (시작 주소는 인터럽트를 요구한 장치로부터 전송되거나 미리 정해진 값으로 결정.)

(교재 69쪽 그림 2-8)

```
t0: MBR <- PC
t1: MAR <- SP, PC <- ISR의 시작 주소
t2: M[MAR] <- MBR, SP <- SP - 1
```

### 인터럽트 사이클의 예

(교재 71쪽 그림 2-9)

## 다중 인터럽트

ISR을 수행하는 동안에 다른 인터럽트 발생

### 처리 방법

1. CPU가 ISR을 수행하는 동안에는 새로운 인터럽트 요구가 들어오더라도 수행하지 않음. (인터럽트 플래그가 불가능 상태.)

2. 인터럽트 요구들 간 우선순위를 정함.

   예) 우선순위가 낮은 인터럽트 요구를 처리하는 도중, 우선순위가 더 높은 인터럽트 요구가 들어오면, 현재의 ISR을 중단하고 새로운 인터럽트 처리.

(교재 73쪽 그림 2-10)