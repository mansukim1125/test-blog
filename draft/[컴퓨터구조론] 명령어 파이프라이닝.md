명령어 파이프라이닝: **명령어를 실행하는 데 사용되는 하드웨어**(예: CPU 내부 하드웨어)를 **여러 단계로 나누어 동시에 처리하는** 기술. 분할하는 **단계의 수가 많아질 수록 처리 속도가 높아진다**.

주제: 명령어 파이프라인 구성 방법, 종류, 특성.

## 2-단계 명령어 파이프라인

명령어 사이클은 기본적으로 **인출 사이클과 실행 사이클로 구분**(교재 57쪽 그림 2-2). 따라서 이를 **인출 단계와 실행 단계**라는 **두 개의 독립적인 파이프라인 모듈로 분리**.

두 파이프라인 단계들에 **하나의 클럭 신호를 동시에 인가해** 동작 시간을 일치시키면:

- 첫 번째 클록 주기: 인출 단계가 **첫 번째 명령어 인출**.
- 두 번째 클록 주기: 실행 단계는 **첫 번째 명령어를 실행**. 인출 단계는 **두 번째 명령어 인출**.

(교재 75쪽 그림 2-11)

### 특성

- 명령어 **처리 속도가 두 배** 향상.
- 문제점: **두 단계의 처리 시간이 동일하지 않으면** 두 배의 속도 향상을 얻지 못함.
  - 해결책: 파이프라인 단계의 수를 증가해 **각 단계의 처리 시간을 같게 함**.

## 4-단계 명령어 파이프라인

각 단계에서 걸리는 시간들이 **거의 같아질 수 있다**. 각 단계는 다음과 같다:

1. **명령어 인출**(IF): 명령어를 기억장치에서 인출.
2. **명령어 해독**(ID): 해독기를 이용해 명령어 해석.
3. **오퍼랜드 인출**(OF): 기억장치에서 오퍼랜드 인출.
4. **실행**(EX): 지정된 연산을 수행하고, 결과를 저장.

(교재 77쪽 그림 2-12)

### 특성

- 명령어 처리 속도가 **4배 향상**.
- 모든 명령어들이 **4개의 파이프라인 단계들을 모두 거치지는 않는다**. 따라서 **거칠 필요가 없는 단계를 불필요하게 거침으로써 시간이 소모**된다. (하드웨어를 단순화하기 위해서는 4개의 단계를 모두 거치도록 해야 함.)
- 파이프라인 클록은 **처리 시간이 가장 오래 걸리는 단계를 기준**으로 정해짐.
- IF / OF 단계가 동시에 기억장치를 접근하는 경우, 기억장치 충돌이 일어나면 지연 발생. (**하나의 기억장치 모듈을 두 단계가 동시에 접근할 수 없음.**)
- 조건 분기 명령어가 실행되면, **미리 인출한 명령어들이 무효화됨.** (교재 80쪽 그림 2-13)
  - 분기 예측: **분기가 일어날 것인지를 예측**, 이에 따라 명령어를 인출하는 **확률적 방법**. **분기 역사표**를 사용해 최근의 분기 결과를 참조.
  - 분기 목적지 선인출: 조건 분기가 인식되면, **분기 명령어의 다음 명령어**, **분기의 목적지 명령어**를 함께 인출해 실행.
  - 루프 버퍼: 파이프라인의 **명령어 인출 단계에 포함돤 작고 고속인 기억장치**
    - **가장 최근에 인출된 일정 수의 명령어들이 순서대로 저장**되어 있음.
    - 만약 **분기가 발생하면 분기의 목적지가 버퍼에 있는지 검사**. 있으면 다음 명령어는 버퍼에서 인출.
  - 지연 분기: 분기 명령어의 위치를 재배치함으로써 파이프라인 성능 개선.

## 슈퍼스칼라

CPU의 처리 속도를 높이기 위해 내부에 **m개의 명령어 파이프라인을 포함시킨 구조**. 매 클록 주기마다 **각 명령어 파이프라인이 별도의 명령어를 실행**하기 때문에 이론적으로는 **파이프라인의 수만큼 프로그램 처리 속도가 향상**됨.

(교재 84쪽 그림 2-15)

### 속도 향상 관계

단일 명령어 파이프라인에 의한 실행 시간: ![Equation](https://math.now.sh?from=T%281%29%20%3D%20k%20%2B%20%28N%20-%201%29&color=black)

m-way 슈퍼스칼라에 의한 실행 시간: ![Equation](https://math.now.sh?from=T%28m%29%20%3D%20k%20%2B%20%5Cfrac%7B1%7D%7Bm%7D%28N%20-%20m%29&color=black)

속도 향상: ![Equation](https://math.now.sh?from=S_p%20%3D%20%5Cfrac%7BT%281%29%7D%7BT%28m%29%7D&color=black)

여기서 ![Equation](https://math.now.sh?from=N%20%5Crightarrow%20%5Cinfty&color=black)이면, ![Equation](https://math.now.sh?from=S_p%20%5Crightarrow%20m&color=black)이다.

### 속도 저하 요인

- 명령어들 간 데이터 의존성.
  - 명령어 실행 순서 재배치: 명령어들 간 데이터 의존성 제거.
- 하드웨어(ALU, 레지스터 등) 이용에 대한 경합 발생.
  - 하드웨어 추가 설치: 경합 감소.

## 상태 레지스터

조건 분기 명령어가 사용할 조건 플래그들을 저장.

(듀얼 코어 및 멀티 코어...)